{"meta":{"title":"RobottDoG.com","subtitle":null,"description":"进一寸自有欢喜","author":"RobottDoG","url":"http://yoursite.com"},"pages":[{"title":"tags","date":"2017-09-21T01:32:09.000Z","updated":"2017-09-21T01:33:16.000Z","comments":false,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"node 及 webpack 版本更新实践","slug":"node-及-webpack-版本更新实践","date":"2017-10-08T02:53:58.000Z","updated":"2017-10-08T02:54:47.000Z","comments":true,"path":"2017/10/08/node-及-webpack-版本更新实践/","link":"","permalink":"http://yoursite.com/2017/10/08/node-及-webpack-版本更新实践/","excerpt":"","text":"前言结束秋招后，提前开始做毕设，项目是基于 DCOS 框架前端部分的二次开发，该项目使用了 react + flux 进行搭建，并使用 webpack 进行打包。DCOS 最新的官方稳定版本 v1.10.0，其 node 版本号：4.4.x ，npm 版本号：3.9.x。在二次开发中，尝试探索软件的新版本，对新的特性加以利用无疑是有帮助的。于是，在开发中决定使用支持进户全部 ES6 的特性 node v6.11.4。（注：笔者写本文时，node.js 的官方 LTS 版本为 v6.11.4，在进行本地升级时使用了 node v7.9.0，但最终还是使用了 LTS 版本。） node 更新配置新的 node 和 npm 版本并进行本地依赖安装，控制台报错，错误信息提示此版本的许多依赖库的版本较低。解决此问题并无更好的办法，一一在 Github 上查询稳定新版本并 npm install –save-dev 进行升级。升级后，npm install 安装成功，并提出以下警告： 更新 webpack3随着 es6 的正式推出，新的 react 插件在其基础上进行开发，webpack1 不能满足新的需求，原项目的 webpack 版本需要进行更新。我选用了官方提供的 webpack v3.6.0 进行项目的打包。项目打包文件构成：123456789- webpack | - plugins |- svg-compiler-plugin.js - proxy.dev.js - proxy.template.js - webpack.config.babel.js - webpack.dev.babel.js - webpack.production.babel.js - webpack.babel.js 工程并没有选择单个的 webpack.config.js 文件进行入口出口的配置，webpack.config.babel.js 文件定义了模块的加载、解析，webpack.dev.babel.js 、webpack.production.babel.js 分别对应了开发环境、生产环境下的配置。 更新过程中，主要依照 webpack 迁徙文档，其中的主要变动如下： resolve 相关选项以 resolve.modules 的形式进行配置 取消在「在模块名中自动添加 -loader 后缀 」 pre 或者 post 属性需要在 loader 中以 enforce 属性说明 更规范的书写除此之外，更新过程中还遇到一些零碎的语法问题，在此汇总并记录： module.constructor()._compile 接口不再接受 undefined 或者 null 值 webpack 的非显式 env_check，用明确的 alias 配置 参考链接：1.webpack 2.1.0-beta.25 error unknown property postLoaders2.Can’t find later-cov.js?3._compile method of module.constructor throws when filename is not passed or is null/undefined","categories":[],"tags":[{"name":"前端开发","slug":"前端开发","permalink":"http://yoursite.com/tags/前端开发/"}]},{"title":"ES6入门：使用箭头函数","slug":"ES6","date":"2017-09-29T12:32:47.000Z","updated":"2017-09-29T13:27:27.000Z","comments":true,"path":"2017/09/29/ES6/","link":"","permalink":"http://yoursite.com/2017/09/29/ES6/","excerpt":"","text":"在 JavaScript 中使用箭头函数返回基本类型许多现代编程语言都支持箭头函数的语法，例如 C#、Swift，而 ES6 也将箭头函数加入到 JavaScript 的语法中。我们在原生的 JS 中已经拥有了匿名函数，但一个更为简洁的表达式不仅方便书写，且能更为直观的表达语义。 当仅有一个参数且返回结果是一个表达式时，语法如下所示：12[1,2,3].map( num =&gt; num*2 )// &lt;- [2,4,6] 如果我们用 ES5 ，他会是这样的：123[1,2,3].map(function(num)&#123; return num*2;&#125;); 当我们不需要参数，或者要传入两个或者更多参数，我们必须用（）来包含这些参数（即使没有）：12[1,2,3,4].map((num,index) =&gt; num*2+index)//&lt;- [2,5,8,11] 当然，更多情况下我们不仅仅返回单一的表达式，还会写一些逻辑语句。这些语句，我们写在 { } 中，如下：12345[1,2,3,4].map(num =&gt; &#123; var multiplier = 2+num; return multiplier*num;&#125;)//&lt;-[3,8,15,24] 同样适用于多个参数的情形：12345[1,2,3,4].map((num,index) =&gt; &#123; var multiplier = 2+index; return multiplier*num;&#125;)//&lt;-[2,6,12,20] 返回对象当我们使用箭头函数返回一个对象时，我们需要使用（）包含这个对象，不然就会出现语法错误。例1中，编译器将 number: n 解析为函数中的语句（number 解析为标签，n 解析为表达式，而这其实是不合法的），但并没有 return 语句，所以 map 的返回值为 undefined。例2中，something: ‘ else ‘ 对编译器来说并无任何含义，所以抛出了语法错误。123456789101112[1, 2, 3].map(n =&gt; &#123; number: n &#125;)// [undefined, undefined, undefined][1, 2, 3].map(n =&gt; &#123; number: n, something: &apos;else&apos; &#125;)// &lt;- SyntaxError[1, 2, 3].map(n =&gt; (&#123; number: n &#125;))// &lt;- [&#123; number: 1 &#125;, &#123; number: 2 &#125;, &#123; number: 3 &#125;][1, 2, 3].map(n =&gt; (&#123; number: n, something: &apos;else&apos; &#125;))/* &lt;- [ &#123; number: 1, something: &apos;else&apos; &#125;, &#123; number: 2, something: &apos;else&apos; &#125;, &#123; number: 3, something: &apos;else&apos; &#125;]*/ 函数作用范围箭头函数的作用范围与其作用域绑定，也就是说当你在函数内部深层嵌套函数时，不用通过 var self = this 或者 .bind(this) 来维持上下文1234567function Timer () &#123; this.seconds = 0 setInterval(() =&gt; this.seconds++, 1000)&#125;var timer = new Timer()setTimeout(() =&gt; console.log(timer.seconds), 3100)// &lt;- 3 值得注意的是，ES6的箭头函数对 this 进行绑定，意味着 .call 和 .apply 不再能改变函数的上下文。 结论当你需要一个匿名函数来返回某些表达式时，箭头函数是简洁的，并在某种程度上让你的代码更加的精简。但并不是任何情况下，都适合使用箭头函数。当参数过多，函数体逻辑较复杂时，命名函数使得你的程序更加可读。箭头函数的优越性体现在函数式编程的情形，.map, .filter, 或者 .reduce。同样，在异步流程控制中，箭头函数消除了大量 callback 函数带来的阅读障碍，会是一个优秀的选择。","categories":[],"tags":[{"name":"ES6","slug":"ES6","permalink":"http://yoursite.com/tags/ES6/"}]},{"title":"写在开始","slug":"写在开始","date":"2017-09-20T14:49:56.000Z","updated":"2017-09-24T00:53:56.000Z","comments":true,"path":"2017/09/20/写在开始/","link":"","permalink":"http://yoursite.com/2017/09/20/写在开始/","excerpt":"","text":"9月17日，提前结束秋招开始暑期中旬去实习，由于入职较晚，公司岗位已经饱和，实习过程中每天都在做基础的数据处理工作，不慎厌烦。做出决定后，于8月5日辞职准备校招，目标岗位是前端工程师。 客观情况春季实习生招聘阶段，一直准备的是 Java后台开发 岗位的准备，春学期拿得出手的项目大概是一个 iOS 的 App，以及基于 Springboot 的管理应用。前端方面的实践不足，是秋招过程中的最大劣势。此外，已经通过HW优招的我，暂时解决了失业忧虑，也给了我很大的信心进行转岗投递。 准备阶段项目经验的不足短期之内无法弥补，但考虑秋招主要考察应届生的计算机基础和编程能力，针对性的复习准备仍有一线希望。 前端基础： 1. 百度前端学院基础练习 2. 《Javascript高级程序设计》 3. 《HTML5&amp;CSS3实战》 算法类： 1. 《剑指offer》 2. leetcode 3. 《编程之美》 网络&amp;操作系统： 1. 《深入理解计算机系统》 2. 《图解HTTP》 技术博客： 1. 阮一峰 2. 百度FEX、360奇舞团、网易考拉等 秋招进程秋招流程无外乎投简历、笔试、面试。虽然没有前端工程开发的经历，但大三学期的相关实践并非一无是处，仍有半数公司给了我面试的机会。 面试中，一面偏向于考察基础知识和算法能力。我所参加的四次面试，均通过了一面。所以我在中旬就停止了算法方面的准备。 二面中，实践经历的缺失成为了阿格硫斯之踵。每当面试官考察一个基础知识点，并将其放到实际开发过程中追问，几乎都答不上来。印象最深的是某游戏的主管，问了我登陆成功后的原界面重定位，习惯后端开发的我停留在 session 解决的层面，并不能给出客户端解决方案，最终挂掉。 回去后思考良久，最终感受到暂时不足以获得一份较好的前端开发offer，决定结束秋招，沉淀一段时间。 9月18日，HW意向书终于等到了HW公司的意向书，但实习经历的身不由己与厌倦感席卷着我。由于业务性质与客户群体，HW公司的 web 前端开发较一线互联网公司有一定差距，且对应届生进行随机分配岗位的做法也让我难以接受。 最终决定放弃这个 offer. 9月20日，开始毕设806C老板得知我的决定后，问了我一句：“觉得大学三年过得怎么样？” 当时并不好意思真实回答，内心觉得，这三年并没有荒度，但作为学生并不成功。 可我还有一年的时间，在NJU做好学生分内事，为职业生涯开启一个好的起点，并用这个 Blog 去简单记录，无聊时候自己看看，聊以自慰。 写在开始。 （9月24日更新） 意外offer前日下午意外的收到了墨灿游戏的正式offer，工作地点、福利待遇、氛围价值观都很满意，准备签约~至此，正式结束秋招。虽然没有进入一线互联网公司，但一个新兴的、发展良好的、有活力的团队不失为好的去处。剩下的大学时光，好好做毕设、回到球队、陪好女朋友，更进一步吧~","categories":[],"tags":[{"name":"闲谈","slug":"闲谈","permalink":"http://yoursite.com/tags/闲谈/"}]}]}